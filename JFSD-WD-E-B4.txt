What is Java Full Stack 
	Front End -> user sees
	Back End -> which runs 24 * 7 -> processing of data, connects to database(SQL, No SQL)
	API -> bridge 


Why Java -> Platform independent, 
			develop web, desktop, mobile
			OOPS -> Object Oriented Programming Language

JVM, JDK, JRE -> Name.java

	Java Virtual Machine -> load, verify, execute code and provides run time env

	Java Runtime Environment  -> implementation of JVM -> libraries + files --> Sun Microsystems

	Java Development Kit -> javac, java etc + JRE + some supporting jars

Java Enhancement Proposal -> JEP
			java 6 -> 2006 , java 7 : 2011., java 8 : 2014, java 9 : 2017
			LTS : Long Term Support Versions -> 8, 11, 17, 21 (current lts version)
			every six months in march and september -> minor versions, non-lts versions

			Back ward compatability..

Install JDK : Open JDK , Oracle JDK, Amazon Coretto JDK..

		Edit environment variables(installed JDK) and edit path (bin)
		cmd -> check java -version		

Install IDE : Integrated Development environment 
		Eclipse, NetBeans, STS, IntelliJ (community - free source, ultimate - paid version)

Configure a folder in IntelliJ
	-> New Project -> created a project with IntelliJ System, add/select JDK
	-> packages -> group of classes
	-> .java extension
	-> Class : Blue print -> objects, methods/functions, refer to another class, variables
		Objects : attributes -> weight, color -> characterstics
				  methods -> actions your perform : drive, applyBrake, soundHorn
				  constructors -> creating and initializing objects

Naming Conventions :
	camelcase : 
		Class Names : UniversityServiceImplementation .. connEctioexception
		method/function, Object Names : applyBrake

	Compilation Error : When you code, you will see errors	
		through cmd : javac HelloWorld.java

	Run Time Errors : When you execute code, you will see errors
		run through cmd : java HelloWorld.java


	Main : public static void main(String[] args){
			public -> access modifier
			static -> key word
			void -> return type
			main -> name of the Method
			String[] args -> input parameters/method signature.. Array of String arguments
	}

	From static methods you can't refer non-static variables or methods directly
		Create an object for class, from object you can refer non-static attributes in static methods


	Comments :
		    /* comment
   			 * something */

			//    comment	

Object Creation :

	NameOfClass objName = new NameOfClass();
	create any number of objects for a class
	name of object in a method should be unique

A method inside a method -> compilation error


Task :

Create a class `Student` with a non-static variable `studentId` and a static variable `universityName`. 
Write methods to display `studentId` and `universityName`, 
and a static method to update `universityName`.
In the `main` method of `Student`, create two `Student` objects, assign different `studentId` values, display their details, update `universityName` using the static method, and display the details again. 
Observe how the change in `universityName` affects both objects.

16/10/24 

	1. primitive Data Types : Stores simple values directly in memory 
		byte : 8-bit (-128 to 127)
		short : 16-bit
		int : 32-bit
		long : 64-bit
		float : 32-bit , floating point number (single precision)
		double : 64-bit, floating point number (double precision)
		char : 16-bit unicode charcter, single alphabet
		boolean : true or false

	2. Non-Primitive Data Types or Reference Data types : store references to objects(memory address)

		String : sequence of characters (number, alphabet, spcl charcters)
		Arrays : group -> collection of elements of same data type
		Class : blue-print of objects
		Interfaces : set of methods which class implement
		Enumerator .. Enum : represent fixed set of constants

	3. Wrapper classes: wraps around primitive data types : Objects
		a. When you work with Collection of Objects
		b. Generics
		c. autoboxing -> primitive to wrapper and vice-versa -> unboxing
		d. Data Conversion : Type Casting
		c. to store null values
		e. Serialization : conversion of objects to byte stream

instanceof -> objectName instanceof DataType/ClassName -> true	

toString -> can't NPE
String.valueof() -> handle NPE

		Integer myInt = null;
        Integer.valueOf(myInt);
        myInt.intValue();	

//byte < short < char < int < long < float < double

narrow -> Manual Cast
and wide casting -> automatic casting

Variables :
	Local or Instance : Scope is limited to method
	Global : scope is limited to Class		

Literals : Values assigned to variables

Identifiers : names you give to variables, methods, classes, packages

KeyWords : predefined functionality and they can't be identifiers

17/10/2024

Operators : perform some calculations/operation on variables or values

	Arithmetic Operators : Basic Math : + , -, *, /, %(modulus), ++, --
		++a -> PreIncrement
		a++ -> PostIncrement

1)++Post-Increment (a++):++we use a++ in our statement if we want to use the current value, and then we want to increment the value of ++a by 1.
2)Pre-Increment(++a): We use ++a in our statement if we want to increment the value of ++a by 1 and then use it in our statement.

	Assignment Operators -> =, +=, -=, *=, /=, %=, &=, |=, ^=, >>=, <<=
		int a = 6 
		a += 5; --> a = a(6) + 5 => 11
	Comparison Operators/Relational Operators -> ==, !=, >, <, >=, <=
	Logical Operators : &&, ||, !
		&& -> If one statement is false, result will be false
		|| -> If one statement is true, result will be true
	Bitwise Operators &, |, ^, ~, <<(Signed left shift), >>(Signed right shift), >>>(Unsigned right)
	Unary Operators :  ++, -- (Pre and Post), 
			Unary plus , 
			unary minus, unary !
	InstanceOf Operator : instanceof
	
	Ternary Operator ?
		condition ? expression1 : expression2
			condition == true then expression1 will be executed
			condition == false then expression2 will be executed

Conditional Statements : if, if-else, if-else-if, nested if
	Scanner -> take input from user
	Debug your code -> put breakpoints, start in debug mode

Switch Statement : switch, case, break
	When you have to check multiple conditions, instead of "if", we can use Switch

Loops : for, for-each/enhanced for -> Collections, nested for, infinite-for loop
		If you want to execute a piece of code many times until the condition is satisfied
			for loop :
	 	for(initialize a variable; condition; increment/decrement.. post or pre operator)
		nested for loop : loop inside loop 

		while : repetetive block of code execution as long as condition is true, 
		do while : atleast once, execute code irrespective condition
		infinite loop using while

jump statements -> break, continue, return 

Push your code to github

Install git : https://git-scm.com/downloads


Repository : https://github.com/kavyamaremalla/JFSD-WD-E-B4

git clone https://github.com/kavyamaremalla/JFSD-WD-E-B4.git --> for the first time
git pull -> daily, you will get updates.

Push your code from your system to github repo :
	
	git add .
	git status -> Optional, to check what files you are going to commit
	git commit -m "Your_Message"
	git push

Submit a task :
	Don't add zip files
	Add question and screenshot of your output
	Follow proper naming conventions
	Add comments, describing what the method does

21/10/24 : Arrays : 
		Data structure -> stores fixed-size of same data type elements
						  organize data -> to access, modify, manage
						  index -> starts with 0 and this is position

		Types of Arrays ->

			One-Dimensional Array -> A linear list of elements
			Two-Dimensional Array -> A table like structure.. rows and columns just like matrix	
			Multi-Dimensional Array -> more than 2 dimensions

			length -> size of array		  

Insert -> Adding an element into array
			arrayName[indexPosition] = valueOfElement;

Read an Array -> for loop
				 Arrays.toString(nameOfArray) -> prints you whole array

Update an Array ->
	
	nameOfArray[indexPositionToUpdate] = upadtedValue

	    int[] numbers = {1,2,3,4,5};

        numbers = Arrays.copyOf(numbers, numbers.length + 1);
        numbers[5] = 61;

Search and Sort in Array    

AccessModifiers : class, method, constructor, attributes

    public : for all classes irrespective packages -> through out your application
    private : code is accessible within the declared class
    default : code is accessible within same package
    protected : code is accessible in the same package and subclasses (child classes in other package)

Non-Access Modifiers :

	final : classes/attributes/methods -> can't extend/can't modify/can't override
	abstract : class/method
	static : method,attribute level
	transient attribute/method level
	synchronized : one thread at a time
	volatile : attribute -> cache thread locally

22/10/24 :

Introduction to Strings :

String : A sequence of characters and it's considered as Object in Java. 
		 String is an immutable object -> once created it can't be changed	

String Methods :
			
			length
			charAt(index position) -> character
			indexOf("character") -> position
			concat -> combining string
			toUpperCase / toLowerCase
			equals/equalsIgnoreCase, == (memory/reference)
			repeat
			trim -> removes whitespaces from ends
			replace -> replace a character
			subString -> only begin index or begin inclusive, end exclusive index

String Builder vs Buffer : like string but mutable
		Buffer -> thread-safety, synchronous
		Builder -> not-synchronized, faster execution
		reverse -> in built methods

String Manipulation -> substring, replace, concate 

String Constant Pool (SCP) ->	special memory inside heap memory where string literals 	are stored.
	(String name = "John" -> literal gets stored in String pool.. 
	String surname = new String("Doe").. heap memory -> String Object)

	Literals : Java checks if string exists 
	-> If exists, it points/refers to existing object
	-> Else, it creates a new object

Regular Expression : RegEx -- https://regex101.com/
				Patterns used to match character combinations in Strings
				[aA0-zZ9]
				\d -> decimal
				\D -> non-decimal
				\w -> decimal + non-decimal
				\W -> special characters or alpha-numeric
				. -> \w + \W
				.*
				.+

Math Operations -> java.util.Math
				sqrt
				abs
				min
				max
				round
				floor
				ceil
				log
				random

Object Creation :

		new key word
		clone -> copies of objects
		Constructor<ClassName>
		Class<?>
		Serialization and deserialization

Constructors : create an object 
			   Special method used to initialize objects, set initial values for object attributes
			   Constructor will be called when an object of class is created		

Types of Constructors :

	1. Default Constructor -> Java provides through Object.class
	2. Parameterized Constructor -> any number of arguments
	3. No Argument Constructor -> set initial values, and no parameters

OOPS  : Object Oriented Programming

		based on the concept of "Object" -> both data and methods

	Principles :
		
		Encapsulation : Wrapping data(variables) and methods into a single unit.
		Inheritance : A class can inherit properties and behavior of another class.
		Polymorphism : Single action can behave differently based on the object on which it works./ which exists in multiple forms
		Abstraction : hiding internal logic/implementation and show the essential features.
		Assosciation
		Aggregation
		Composition

Inheritance : is-a relationship 
			It's possible to inherit attributes and methods from one class to another class

			  subclass -> child -> this is the class which inheits prop/behaviour from another class
			  superclass -> parent -> this is the class which is being inherited from	

			  extends keyWord -> child extends parent
			 
			  multiple inheritance -> not supported
			  				extending two classes

			  single -> only one class extending one parent				

			  Why multiple inheritance using extends is not supported 
			  				- complexity :  should be readable and simple
			  				- Diamond Problem 
			  					same method names or same variables in two parent classes then child will get confused/ambiguity which one to pick				
			  multi level inheritance -> supported
			  		Car extends Vehicle and Vehicle extends HelloWorld

			  hierarchical -> multiple children for a parent	-> supported				

			  hybrid -> hierarchical + single (HelloWorld)	


This & Super KeyWords : 

			this : refers to the current instance of a class, used to access instance variables and methods for current class
			super : refers to the parent class object, used to access instance variables and methods for parent class

			super -> called parent's objects and methods
			this -> to eliminate the confusion between class objects and parameters in constructor with the same name
				Call another constructor in same class :: Constructor Chaining
				this.age++ -> returning the current object.. method chaining
				can pass current class object as an argument using this keyword

Polymorphism : "many forms" : Occurs when we have multiple classes which are related to 				each other by inheritance... you can do single action in multiple ways

			-> Compile Time Polymorphism -> Method Overloading -> Static Binding

					multiple methods with same method name in same class can exist until the input parameters doesn't match
					Return type -> int -> count of i/p parameters doesn't match
						method1 -> int a, int b, int c
						method2 -> int a , int b
					Void Return Type ->
						count matches but type of data in input parameters doesn't match
							
					During compile time, jvm will decide which method to call

					Ambiguity -> when compiler can't decide which method to execute
						prevention : give proper i/p so that compiler understands

			-> Run Time Polymorphism -> Method Overriding -> Dynamic Binding
				During run-time jvm determines which method to run/call
				From Parent, we can create a child class object

			@Override : Indicate that method in child is intended to override the method 	in parent class
				-> If method is not present in parent, but when we try to override in child, it gives compilation error.
				-> Applicable only on method not on constructors/variables
				-> Checks for name of method, count and type of input parameters, return type of parent method -> If it doesn't match, throws compilation error.
				-> Improve readability 

				-> Cannot override a static method in parent

Encapsulation -> Hiding our sensitive information from users.
		-> variables/methods/constructors/attributes :: declare them as private
		-> how to access and update private variables ? -> getters and setters..
		-> Improved security and flexibility

Abstraction : Data Abstraction is hiding complex implementation/logic and showing the 				  essential details... 

	Achieve abstraction -> using abstract class or using interface

			  abstract class -> abstract keyword on classes/methods not on variables

			  		this class can have abstract methods and non-abstract methods

			  	Method : 
			  	
			  	abstract -> should not give body
			  	Suppose we extend this abstract class by any child class -> must override this abstract method, orElse compilation error
			  			non-abstract methods may or may not be overriden

			  			For abstract methods -> sub-class/child will give the body/implementation		

			  	Create objects ->
			  		When we create object for parent it will bring all the abstract methods along with new object
			  		Restricted class -> inherit class and create object using sub class						
			  
			  interface ->	Purely abstract -> we can achieve 100% abstraction

			  	abstract methods -> Before Java 8
			  	default and static methods -> After Java 8

			  	implements -> keyword you will use on classes to implement interface

			  	By default, all the methods in interface are abstract.
			  	If we try to give a non-abstract method ->

			  	   public void eat(){
        			System.out.println("Animal is eating");
    				} --> in interface, this gives compilation error.
			  
    			can't extend an interface by class, we should implement an interface.	
    			An interface can extend interface.	

    		Multiple Inheritance through Interface is supported

   Abstract Class : partial abstarction, contains both abstract and non-abstract methods, a sub-class can extend only one abstract class

   Interface : full abstraction, all methods are abstract by default, a class can implement multiple interfaces 

Assosciation : objects --> one-to-one, one-to-many, many-to-one, many-to-many --> mapping

Aggregation : has-a relationship -> parent and child exist independently

				Ex : An engine can exist with out a car

Composition	: parent and child are dependent

				Page --> Book

	Task : Try to do practical examples on assosciation, aggregation and composition			

final keyword :

	variable -> can't change the value of variable.. it will be constant.
	method -> can't override a final method
	class -> can't extend, prevents the class being a child/subclassed   


toString -> a string representation of object 
			good practice to override toString to read a meaningful object during debugging
			display readable format of an object not some random address.


hashCode and equals : to compare two objects effectively
				equals -> if object values are equal(every field in object should be equal)
				hashCode -> provides hash-code value so that objects can br grouped.

POJO : Plain Old Java Object

	DTO, entity, model

	Used to represent data -> declare fields, getters and setters, constructors, toString, hashcode and equals.

	Just used for data storage and retrieval

Immutable Class : whose objects can't be modified once created.
			To maintain consistency, thread-safe

By default, you have String..

			how to create an immutable class :

				1. Declare class as final -> prevents sub classing
				2. Make all fields private and final -> prevent modification
				3. Don't provide setter methods
	

Exception/Error Handling : 

		try : Where we put piece of code which may throw exception
		catch : handle the exception thrown by try block
		finally : After try-catch even if an exception is thrown or not this block will be executed..

		try-catch-finally : db operations, file handling, n/w connections

		Finally block will not be executed if 

			-> System.exit, JVM terminates the program
			-> exception in finally block and if you don't catch it
			-> infinite loops/waits
			-> thread death
			-> System crashes

		one try	can have multiple catches and a single finally block

			multiple catches -> follow hierarchy in blocks,For eg: first block if we give parent(eg : Exception) and second block (NullPointerException) -> throws compile time error.

		one method can have multiple try blocks.

Exception hierarchy -> 

	Object -> Throwable -> Exceptions -> 
								Checked Exceptions : CompileTime -> ClassNotFound, etc
									Exception should be handled by User, shouldn't extend RunTimeException
								UnChecked Exceptions : RunTime -> Arithmetic, NullPointer etc
			Throwable	-> Errors --> Eg : Assertion Error, OutofMemoryError, StackOverFlowError, etc

throw -> line level, throw an exception for a method
		  can't throw multiple exceptions
		  throw new Object of an Exception

throws -> can declare multiple exceptions, this is at method level
			throws ExceptionClass

CustomExceptions/User-Defined Exceptions :
	1. extend Exception
	2. call Parents'constructor from child(user defined exception class) constructor

Errors : unrecoverable
		 occurs during run time
		 mostly due to env setup of application
		 It can't be caught or handled
		 
		Ex: StackOverFlowError

Collections : It's a framework used in managing and grouping objects -> provided some set of interfaces and classes

Iterable --> Collection -> use non-primitive or wrapper classes.. we can't use primitive data types, it gives compilation error.

					List : ArrayList, LinkedList, Vector, Stack 
					Set : HashSet, LinkedHashSet, 
						SortedSet : TreeSet
					Queue : Priority Queue
						Deque : ArrayDeque

Exist independently -> Maps -> keys and values pair	: HashMap,  LinkedHashMap, Hashtable
							SortedMap : TreeMap	


List -> allowing duplicates, insertion order

	Collections.sort(list) -> ascending order
	
	add -> inserts an element
	remove -> deletes the element at given index position
	get -> brings an element in given index position
	contains -> true if element is present in list and false if element is not present in list
	update -> list.set(2, 9); -> replaces index 2 with element 9

	Linkedlist -> removeFirst, removeLast, removeFirstOccurence, removeLastOccurence	

		Singly
		Doubly
		Circular

	Vector -> synchronized
	
	Stack -> Last In First Out (LIFO) principle

		push, pop, add, get, contains, remove, peek -> last index positioned element i.e., top of the stack, set methods

		. duplicates & null values are allowed
		. remove, removeAt, add, addAt etc

Set : No duplicates allowed

	add, remove, contains
	no concept of index -> you can't get an element


		hashSet :  Unordered
					. no insertion order, based on hash of objects it inserts & displays the values
					. allows null values
					. removeIf, remove, removeAll

		treeSet :  SortedOrder -> 
					numbers -> ascending order
					String -> dictionary order

  					. no null values allowed
  					. uses comparable, only the comparable objects are allowed

		linkedhashset -> follows insertion order

Null -> one null is allowed in set	
		many nulls are allowed in list

Efficiency -> Time Complexity and Space Complexity.

Map : stores objects as key and value pairs
		key -> acts like index and it's unique
		value -> data value

		put -> to insert key and value into a map

		get(key) -> returns you value corresponding to the respective key

		remove -> returns value and removes key, value pair from the map

		clear -> removes all the pairs in map

		keySet -> returns set of keys ->no duplicates allowed

		If we put same key, different value -> updates value to the same key

		values -> Collection of Values/data

		entrySet -> set of entries of key and value pair
			entry -> one key and it's value is called entry

		for (Map.Entry entry : hashMap.entrySet()){
            System.out.println(entry);
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        	}

        containsKey, containsValue	

hashMap: internal working of a hashmap

	. no order, based on hashing it gives result
	. duplicates keys are not allowed, duplicate values can be allowed
	. you can update value while creation itself
	. allows null key and null values

	linkedHashMap -> Map + hashmap : allows null key and null values, follows insertion order

	TreeMap -> Map + sorted map : doesn't allow any null keys and null values are allowed.
			Sorted by key

Queue : Implemented by 
			PriorityQueue
			LinkedList
			ArrayDeque
		Extended by -> Deque, BlockingQueue, BlockingDeque

		. FIFO -> First In First Out
		. create & adding elements to queue
		. read queue
		. allows duplicates
		. doesn't allow null
		. pull, element, remove, add, peek


Deque -> extends Queue
		ArrayDeque

		. LIFO -> Last In First Out	 & FIFO -> First In First Out
		. we can add/remove elements from both sides
		. insertion order
		. null values not allowed
		. duplicates are allowed
		. pollFirst, pollLast, removeFirst, removeLast, addFirst, addLast, removeLastOccurence, removeFirstOccurence, offerFirst, offerLast, peekFirst, peekLast

06/11/24 :

Multi Threading : Extension of multi processing
		Threads -> each thread can run parallely

Life Cycle of Thread : 

	new Thread() -> creates a thread
	start() ->	Runnable 
			-> Thread runs -> Running
				-> wait/suspend/sleep
				-> dead -> end of the execution
	Priority -> scheduling the threads
			1(Min_Priority) to 10(Max_Priority), 5(Norm_Priority)		

Create a thread ->
			implement Runnable/Callable interfaces
				Runnable -> just runs
				Callable -> throw exception and return some result
			extends Thread


Communication between threads :

	If threads wait for each other -> Synchronous Communication
	If threads don't wait for each other and run parallely -> Asynchronous communication							
	Prefer implementing over extending -> you can implement multiple interfaces but can extend only one class

	deadlock -> when two threads wait for each other..
		synchronized keyword

Java 8 : Advanced Java 

	Features : What changes they made/ what they introduced newly

		Functional Interfaces
		Lambda Expressions
		Stream API
		Method References
		Optional.class
		forEach
		Collectors class
		Date and Time Changes
		Default and Static methods in interface

Functional Interfaces : single abstract method (SAM)
	custom FI -> create an interface and annotate with @FunctionalInterface, write an abstract method
	if you add one more abstract -> it will throw compilation error.

		FI extends other FI -> make sure through out you have a single abstract method

		FI extends normal Interface -> make sure through out you have a single abstract method

		Types : (Bi)Consumer, Supplier, (Bi)Functional, (Bi)Predicate

Lambda Expressions :: To write clear anonymous functions on SAM interface, we use lambda


	() -> expression;

	parameter -> expression; (symbol ->)

	(parameter1, parameter2) -> expression

	(parameter1, parameter2) -> {
		code logic
	}


	we don't have to write return keyword 
	We can't use for any type of class .. applicable only on interfaces

Stream API : on any collection -> to process data we use streams API
			Eg : forEach, filter, map, object(like product), Stream.of, flatMap

Consumer -> only accepts, doesn't return

		single i/p argument -> accepts and performs some logic

		BiConsumer -> two i/p arguments

		create a List using -> Arrays.asList
		forEach on a Collection -> Consumer

Predicate -> predict output -> represents some condition or filter, accept i/p and return boolean.. 
			Commonly used for filtering collections

		Predicate -> one i/p argument
		BiPredicate -> two i/p arguments

		Eg : filter -> Predicate


Function -> takes i/p and gives some o/p

		Function -> one i/p and one o/p

		BiFunction -> two inputs and one o/p

		Used for mapping values or transforming values

Supplier -> gives results, doesn't take input
		
		Supplier -> one result

Functional Programming	-> Java 8 supports functional programming

	By implementing lambdas, we can achieve functional programming
	-> more readable, less code, less debugging, more concise

Optional -> An object may or may not contain a value, could be null.. to handle these null values, we use Optional Class	

Method References -> Replace to lambda, used often on functional interfaces

	Notation ::
	More readable
	We can have one argument in lambda as i/p parameter for a method to use method reference

	Types : 
		Reference to a static method
		Reference to a constructor
		Reference to a non-static(instance) method

Callable -> similar to runnable, but diff is this returns output and throws a checked exception

Future -> result of asynch comm'ctn. It provides method to check if the computation is complete and wait for the completion then bring the result.

Use Case : suppose you have some async communication and you want result later, eg : loading data in background!

CompletableFuture and CompletionStage :
	CompletableFuture is part of java concurrency API -> provides asynch programming by implementing the CompletionStage -> this allows composition of tasks which depend on one another

Default and Static methods in interface

	-> provides more flexibility and reduces the need for abstract classes

Default : allows interfaces to have implementations that can be used or overriden(optional) by implementing classes., enable backward compatability.

Static : provides a way to add some utility methods directly into interface, which can be called without an instance of implementing class.
	Directly called from interface not from child object

Date and Time Changes

	Java 8 -> new Date Time API 

LocalDate, LocalTime, LocalDateTime -> java.time package

ZonedDateTime -> date-time with timezone	

Instant -> timestamp(relative to UTC)

ChronoUnit

Duration and Period
	Duration -> measures amount of time in hours, seconds, minutes -> used for time based calculations
	Period -> measures amount of time in years, months, days -> used for date based calculations
		
Temporal Adjusters, DateTimeFormatter -> read about this

Private methods in Interface -> from Java 9
	Allow developers to encapsulate common code within interface
	These can be used either by default or static methods in interface, not possible with abstract methods because they don't have body.

	Use Case : 
		Avoid code duplication within interfaces
		Allows to use common logic

var KeyWord	: Introduced in Java 10
		For any local variable type, allows compiler to determine the type of variable based on assigned value

	Use Case : to ensure type safety	
		mostly used in iterators(loops), simple data types, stream api

	 var num = 16;
     var nameOfPerson = "Peter";

        System.out.println(num + " Person is " + nameOfPerson);	

 Limitations :
 
  We can use this keyword for local variable data type replacement only
  	Can't use as global variable
  	Can't be applied as method input parameters, method return types  
  	Can't initialize null values using var keyword
  	Can't be used as static variables

Text Blocks : Introduced in Java 13 

	Allow for multi line string literals enclosed """

	Use Case : Simplify creation of multi line strings especially during SQL queries, JSON, HTML etc in Java

Records : Java 14 introduced

	compact way of defining a immutable data classes that only need data type and name of the fields

	Java compiler ->	built in parameterized constructor, getter for every field, toString, hashcode and equals

	can create and refer to static variable and static methods

		Use this for simplicity/readablity and immutability, reduces boiler plate code

Switch Expression Changes
	Java 12 : Introduced lambda, return values from switch case

	Boiler plate code

	Java 17 : multiple statements in case
		yield to return a value

Collectors API & Immutable Collections -> Once created, state can't be changed

	Introduced in Java 9

	To create immutable collection so that no body can modify it.

	Set.of, Map.of, List.of

	Collectors.toUnmodifiable List or Set or Map


Sorting -> only in modifiable list, can't do in immutable list

Collections.sort(list); -> by default it gives ascending order

Collections.sort(list, Collections.reverseOrder()); or list.sort(Collections.reverseOrder()); 

Enumerator -> enum keyword to create 

spcl class representing group of constants (unchangeable variables like final variables)

Generics : Allow you to write classes, fields, interfaces, methods with a place holder for types -> type-safety and reusable

	<>-> generics

	HELP in preventing run time errors by catching the type mismatches during compile itself

	T : Type -> data types	-> Optional
	E : Element. in collections to rep type of elements stored -> List
	K : Key, used in maps for rep keys -> Map
	V : Value, used in maps for rep values assosciated with keys -> Map
	S, U, V, W -> for additional types -> BiConsumer

Comparator -> 

Comparable -> +ve (a>b), 0 (a=b), -ve(a<b)

Premium courses : https://www.guvi.in/courses/?current_tab=paidcourse

l)java for beginners
2)my SQL
3)Git
4)Agile fundamental
5)react.js
6)deploying react.js on aws
7)Aws fundamentals
8)Aws
9)dsa in java
10)master in Mongo DB

1. Print a 2D matrix with 4 rows and 4 columns.
	
		a. 4 * 4 matrix with default/some values through code
		b. take input from user and print matrix

2. You are given a list of lists containing integers. Create a stream to flatten the nested lists, remove duplicate integers, and then find the square root of each distinct value.

List<List<Integer>> nestedLists = Arrays.asList(
  Arrays.asList(1, 2, 3),
  Arrays.asList(3, 4, 5), 
  Arrays.asList(5, 6, 7),
  Arrays.asList(7, 8, 9)
);		

3. Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be fit if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [1,3,5,6], target = 2
Output: 2

Constraints:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums contains distinct values sorted in ascending order.
-104 <= target <= 104

Git : version control system -> Before git, they used svn
	github, gitlab, bit bucket

Why ? Help you to track changes of code
 commits	-> who changed the code, what code was changed, when did they change
 used for colloboration

Install git : https://git-scm.com/downloads

	cmd -> git --version

	git config --global user.name "Yourname"
	git config --global user.email "yourEmail@gmail.com"


Push your code to github

Repository : https://github.com/kavyamaremalla/JFSD-WD-E-B4

Remote -> in your github acc/bit bucket/ gitlab

local -> your PC

git clone https://github.com/kavyamaremalla/JFSD-WD-E-B4.git --> for the first time
git pull -> daily, you will get updates.

Push your code from your system to github repo :
	
	git add .
	git status -> Optional, to check what files you are going to commit
	git commit -m "Your_Message"
	git push

Local Folder -> Add it to repository and push it to github	

Navigate to the folder which you want to make as repository ->	git init

	ls -> list of files in the folder
	git status -> status of files

	Tracked -> git knows that these files will be added to repository
	untracked -> files are in directory but not added to git

	local -> staging -> remote

	git add fileName
	git add -all (git add -A) or git add .

	git status --short

		?? -> untracked files
		A -> added files
		D -> deleted files
		M  -> Modified files

	git remote add origin https://github.com/kavyamaremalla/my-project.git

	git remote -v 

	created a repo -> my-project in github

	git commit -m "your message of commit"

	git push -u origin master

	git help

	git commit -help	

Git branch : new/separate version of your main repository

	git branch -- list all the branches

create a branch through github

	git branch new_branch_name
	git checkout new_branch_name

	Compare and pull request -> raise a PR
		shared to developers for review
		merge code to destination branch

		git merge branch_name -> locally

		 git branch -d bug1/feature_payments
			Deleted branch locally bug1/feature_payments (was 433b658).
		
		git push -d origin bug1/feature_payments
		To https://github.com/kavyamaremalla/my-project.git
		 - [deleted]         bug1/feature_payments


Git work flow -> deployment

	git pull -> git fetch(reading changes) + git merge(writing changes locally)

	commit -> a commit id

	git log -> history of commits

	git revert -> reverts changes

	git reset commit_id -> goes back to that particular commit

	git rebase vs git merge

	rebase : All the commits on a feature branch are combined into a single commit on the master branch. All commits are rebased, and the same number of commits are added to the master branch.

	git rebase doesn't preserve commit history but merge preserves.

	git stash

		When ever you perform a push
			-> always take a pull
			-> always merge main branch with your feature branch

		git stash apply stash@{n}
		
			git stash apply -> will apply stash @ 0.

	Right click on a file
		git -> commands
		local history -> shows all history file	

	Settings in repository -> delete a repository.			

HTML -> Hyper Text Mark Up Language

	-> create web pages
	-> describes structure of web page
	-> contains series of elements
	-> used to tell browser how to display content

Visual Studio Code ->	

Extensions :
	vscode-icons : icons in vs code
	Prettier - Code formatter : to format any UI code
	Live Preview -> run code in vs code tool
	GitHub Actions -> git commands

HTML Tags -> define html elements with tags

< starts with and ends with >
	opening tag <>
	content
	closing tag	</>

	<tagName> content to display </tagName>

<!DOCTYPE html> -> first tag browser interacts with & this means you are using HTML5 version.

html tag -> root element
head -> meta info abt page & body -> all doc body.. tables, images, links, headings, paras etc

h1 to h6, p tag, a tag (anchor).. href -> attribute

img tag

 	Absolute url -> link external image
	relative url -> your domain

element -> starting tag to closing tag

empty elements -> no closing tag : br, hr

Attributes : additional info about elements, always specified in starting tag, usually exist in pairs

 style="
      background-color: aqua;
      font-size: 100%;
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      text-align: center;
      color : blue
    "

   <title>
   Favicon -> image near the title
   	 <link rel="icon" type="image/x-icon" href="images/sunset.jpg"> 

<b> -> bold
<strong> -> bold but more priority

<i> -> italic
<em> -> emphasized.. italic but more priority

<sub> -> subscript
<sup> -> super script

<del>, <ins>

Semantic tags : header, article, section, footer, nav

tables : table, tr, td, th

units : %(parent), px(1/96th of inch and multiples of 16), em(element), rem(root element)	

	 1em = 16px
	 1rem = 16px
	 100% = 16px

padding -> space btwn cell edges and cell content
spacing -> space btwn one cell to another cell

zebra stripes in tables

colspan, rowspan

colgroup


Lists : ordered, unordered, descriptive
		nested lists -> list inside a list

	li, ul, ol, dl, dt, dd

	ul -> style : list-style-type -> disc, square, circle, none
	ol -> type = A/a/1/I/i, start = "50"



Tags : div and span

	class to style -> .ClassName
	id to style  -> #IdName


Forms : Collect user input & through backend we send this info to process further

 <form>
        <label for="username">UserName: </label>
        <input type="text" id="username" name="username" placeholder="Enter your username"> <br> <br>
        <label for="pwd">Password: </label>
        <input type="password" id="pwd" name="pwd" placeholder="Enter your password"> <br> <br>
        <button type="submit">Submit</button>
    </form>

    type -> validation and types of input (checkbox, radio,email, tel etc)
    bind label with input we give for and id as same values

    name -> value of i/p will be sent further.

    
Html and css tasks :

For 7 and 8 question in html, kindly create a card size form by taking aadhar,pancard instead of given link. For 8, you can use below reference to create table https://i.stack.imgur.com/aJIRk.png

Form atrributes : 

	action -> data sent to file or link (useful when working with backend)
	target -> tells where to display response
			_blank, _self(default),_parent,_top, framename
	method : get, post
	autocomplete -> suggestions while filling the form
	novalidate -> will not validate types		

Form Elements :

	form, input, label, textarea, fieldset, legend, option, select, optgroup, output, button, datalist

Input Types :  radio, check, password, email, range etc

Input attributes : value, readonly, disabled, size, maxlength, min, max, multiple, pattern, placeholder, required, autofocus etc

Form attributes : method, action, target, novalidate, autocomplete etc

CSS : Cascading Style Sheets -> html elements

CSS Types :

	Inline -> applying in starting ta
	Internal -> in html
	External -> separate file and import it in html

	Using class and id, we can apply styles

Box model : describes the dimensions of an element(content, padding, border, margin) -> to understand the spacing and sizing of an element or section

content : content of the box where you have text, images, links etc
padding : area around the content.. transparent
border : goes around padding and content
margin : area outside the border..

CSS Selectors : class(.), id(#), universal selector(*), 
grouping selector(table,td,th)

CSS Flexbox : flexbox modes
		block ->  sections in a webpage
		inline -> for text
		table -> for 2D table data
		positioned -> for explicit position of an element

	flex-direction -> row, column, reverse for row and column
	flex-wrap -> nowrap(default), wrap, wrap-reverse
	flex-flow -> row wrap -> direction + wrap
	justify-content -> center, space-around, space between

Media Queries : Responsive design, we use media queries :
	
	Apply styles based on screen size or devicce size.

 same website : tv, laptop/PC or tablet or mobile -> it shouldn't loose its characteristics.

Breakpoints in media queries

display :
	none
	block
	inline
	inline-block

navbar -> using ul and display

CSS Positions - relative , Absolute , static(default) , fixed, sticky

creating layouts -> flex, grid, float

Create a Landing Page Using HTML , CSS

Deploy UI Code : render, netlify(more popular), firebase(backed up by google), github deployment

RWD : Responsive Web Design -> layout and content adapts to any screen size to different screens or designs
	
	TailWind CSS -> framework on CSS -> utility classes -> utility first approach
		install node and install tailwindCSS
		https://tailwindcss.com/docs/installation

		link tailwind CSS in html using tailwind CDN link

     <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">

     sm -> 640px
     md -> 768px
     lg -> 1024px
     xl -> 1280px
     xxl -> 1536px

	BootStrap -> framework ->pre-defined classes -> component first approach

Mobile-First approach -> designing for mobiles first and them for larger screens., by default bootstrap follows this.

Set-up bootstrap -> install using npm or through links in html.

Layout : built using grid system -> flexible, responsive structure for creating consistent designs across devices.

grid -> row, columns -> responsive layouts

Each row in a webpage is divided into 12 columns

	    <div class="container">
        <div class="row">
            <div class="col-md-6">Left Column</div>
            <div class="col-md-6">Right Column</div>
        </div>

Layouts using Bootstrap's utility classes :

fixed-layout -> container : fixed-width
fluid-width layout -> container-fluid -> full-width container
responsive layout with breakpoints -> container-md
		xs -> <768px : phones
		sm -> >=768px : tablets
		md -> >=992px : small laptops
		lg -> >=1200px : laptops and desktops

Bootstrap classes : 

	tables
	container
	typography -> text-center, fw-bold, text-primary
	spacing -> m-3, p-2, mt-4
	colors -> bg-success
	button -> btn
	forms -> form-control, form-check
	grid -> row, col-6, g-3(gutters)		
	spinner -> which loads when we open some page
	scrollspy -> inline with document -> we will navigate in navbar
	navbar -> navigation bar in any webpage
	modal -> pop-up when clicked on a button
	alert -> gives alert message when clicked on some button
	carousel -> sliding images like we have in amazon
	breadcrumb -> location addressing
Task on pagination.. gives page numbers like a book online or google search
	flex, display, overflow

**************** JavaScript : Dynamic website ****************

Resume -> static page
facebook.com/github.com -> dynamic sites/pages

html -> to define content of web page

CSS -> to specify layout of the web page., styling your html

Javascript ->	to program the behaviour of a web page

html -> <script> means java script --> Internal JS 
		or .js file to use javascript --> External JS

DOM : Document Object Model -> refers html doc
BOM : Browser Object Model -> refers browser

To run js using .js file install -> https://nodejs.org/en/download/package-manager

Variables -> storing data values

Automatically declare eg : x = 8;
ES5 var -> function scope -> older browsers
ES6 let -> block-scoped
ES6 const ->  constant value, block scoped

block-scoped -> can not redeclare

DataTypes -> 8 Data types

	String, Number, BigInt, Boolean, Undefined, Null, Symbol, Object

	Object -> user-defined and in-built

	in-built -> arrays, objects, dates, maps, sets, promises etc
	user-defined -> json
		Java Script Object Notation
		exists in key and value pair like map in java
		JSON objects in .json file

== and ===

	let color = "Red" //string
	let color1 = new String("Red") //object


	console.log(color == color1); //true : check only value
	console.log(color === color1); //false : checks data type and value

Operators : mathematical and logical computations
	arithmetic, assignment, comparison, string, logical, bitwise, terenary, type (typeOf, instanceOf)

Functions :

we can assign a variable to a function
invoking a function

NaN -> not a number

function declaration, function expression(assign to variable), arrow function (like lambda in java), method (function in an object), constructor function(data types constructor), immediately invoking function, selft invoking function, generator function (yield keyword), async function

Array Operations : 

const cars = ["Tata", "kia", "BMW"]
const fruits = new Array("apple", "banana", "guava", "kiwi")

array to String.

forEach ->

function display(val) {
    console.log(val);
    
}

fruits.forEach(display)

Arrow Function : fruits.forEach((val) => console.log(val))

Task : 
Array methods : concat, splice, slice, shift, copywithin etc
join, push,pop, unshift, flat,reverse

Strings :

backticks :- template literals 

let welcomeNote = `Welcome ${firstName}, ${lastName}`
console.log(welcomeNote);

$ -> used to refer variable and without backticks & $ this won't work

Task :
methods : length, charAt, slice, split, touppercase, lowercase, substring etc

Loops : 

foreach -> accepts a function
for -> traditional for.. with expressions or conditions
for of -> loop through values of objects
for in -> loop through properties of objects

QuerySelector

document.querySelector -> selects the first element which matches CSS selector
document.querySelectorAll -> selects all the elements which match CSS selector

AlertBox -> gives user an alert
confirm box -> asks to proceed or not -> sent to backend for processing
prompt box -> user can give input -> sent to backend for processing

Append and Append Child

append -> adds content at the end of element
appendChild -> add an element node to the end of the list

Events : clicks, keypresses

Arrow Function =>

Rest vs Spread Operator ...
	in function it's rest operator
	in arrays it's spread operator

Array & Object Destructure

Array Destructuring : 

	Basic destructuring
	Skipping Elements
	Default Values
	Nested Array Destructuring

Object Destructuring :

	Basic destructuring : extracted properties of object
	Rename the variables
	Default Values	
	Nested Object Destructuring

Destructuring with functions -> Array and Object

Error Handling in JS : 	

	try -> statement which may throw error
	catch -> to handle error
	finally -> block to run regardless of your result
	throw -> custom error

	try {
		block of code to try
	}catch (err){
		code to handle errors
	}finally {
	    run everytime 
	}

Errors : Type Error, Reference , Range, Syntax Error, URI Error, Eval (eval())	

use strict : key word-> if you don't define variables they give error

Asynchronous Programming : API calls, setTimeout, file reading..

Closures -> global variable can be made as a local(private)

Self -Invoking Function -> assign a func to variable and call at the end

Callbacks -> define func, but we pass this as arg to other function and call when required

Promises : definitely promises a result -> resolve and reject
States in promises : 
	FulFilled
	Pending
	Rejected

	Producing code : can take some time
	consuming code : should wait for the result

	setTimeout in a promise

	FileReading using promises

log data from files -> Promises {pending}
	async function and await keyword -> resolve the promise
	remove await -> promise {content of file}
	remove async -> compilation error : await exists with async.. they go hand by hand

Multiple call backs in nested form -> if and else blocks
To overcome multiple callbacks -> we had promises which has three states
try and catch block -> async and await keywords	

Fetch -> fetch() method starts the processing of fetching a resource from server
		fetch() return a Promise that resolves to a response object

Dummy API : https://reqres.in/
		GET -> get data from server
		POST -> insert data into server
		DELETE -> remove data inside server
		PUT/PATCH -> update existing data inside server

fetch 
	using promise : get and post
	using async and await : get and post

Calculator app -> using HTML, CSS and JS	

*************************** Database *******************

Database -> store some data.. organized way
		SQL & Non-SQL

		SQL(Structured Query Language) : RDBMS
			store as Tables -> rows and columns
			MySQL, Oracle, MS-SQL, Postgres, IBM DB2 etc

		NoSQL -> store as JSON objects
			MongoDB, MariaDB, Cassandra, Redis, and Amazon DynamoDB

DBMS : Database Management System : communicate users and db	
	types : hirerachial, relational, network, object oriented

Operations : Create, Read, Update, Delete (CRUD operations)	

Dev (read and write), test, preprod, prod

MySQL : 

Installation and Setup

	Server and WorkBench -> GUI (graphical user interface), shell

Database -> multiple tables inside database

one application can have multiple databases (db1 : sql and db2: nosql)

Query/Command -> to interact with data

DDL : Data Definition Language : create, drop, alter, truncate, rename
	 table level operations

DML : Data Manipulation Language : Insert, Select, Update, Delete
	  data level operations

DCL : Data Control Langauge : Grant, Revoke (access or permissions to users)

TCL : Transaction Control Language : Commit, rollback, savepoint   

create database university; -> creates a db/schema

drop database universities; -> delete a db/schema

show databases; -> Retrieves all the dbs in respective host

create table university.students (
		StudentId int,
        FirstName varchar(10),
        LastName varchar(255),
        isCertified boolean
);

create table dbName.tableName(
		column_Name column_type
	)

drop table todo_management.students;
	drop table dbName.tableName

Create a table from another existing table :

create table marks as
	Select StudentId, FirstName from students;

Alter table :

Alter table students
Add City varchar(100);

alter table students
drop column City;

alter table students
modify column city int;

alter table students
add column LastName varchar(255) After FirstName

Alter table students
Rename column city to City

alter table lecturer
rename to lecturerTable

truncate table dataBase.table_Name -> preserve the structure of table, delete the content(data) inside table

DML :

Insert into students(StudentId, FirstName, LastName, isCertified, City)
Values (1, "John", 'Doe', true, "London");


select * from students;
select * from students where StudentId in ( 1, 2);
select * from students where city = "London";
select * from students where city = 'London' and isCertified = true;
select * from students where city = 'London' or isCertified = true;
select distinct(city) from students; -> unique rows for that particular column
select * from students where not city = 'London';

select * from students where StudentId between 4 and 6
select * from students where StudentId not between 4 and 6 and StudentId not in  (4) order by FirstName desc

Select concat(stu.FirstName, " " , stu.LastName) as FullName from students stu;

select top(5) from students;

Update students set LastName = 'Doe' --> updates whole table
Update students set LastName = 'Doe' where StudentId = 1 and FirstName = 'John'

Update students set FirstName = 'John' where city = 'London' -- update multiple records

Delete from students where StudentId = 2 and/or; --multiple records
Delete from students where StudentId = 1 and city = 'london'; -- single record

select * from university.students; --> deletes data from whole table

diff btwn drop vs truncate vs delete

Aggregate Operations : 

select count(distinct(city)) from students;
select count(*) from students;
select count(*) from students where city = 'London';

select avg(marks) from marks;

select sum(marks) as total_marks from marks;
select avg(marks) as average_mark from marks;

Order By :
By default when we give a select statment -> primary key asc order
select * from marks order by FirstName asc; -> by default asc
select * from marks order by FirstName desc;

Alias : temporarily we can change the name of the column

select min(marks) as Minimum_Mark from marks;
select max(marks) as Maximum_Mark from marks;

select FirstName as Student_FirstName from marks;

Like : select * from students where LastName like 'P%r'

Constraints -> on table column level

	Unique -> distinct
	not null -> shouldn't be null
	default -> default values if not provided during insertion of data
	check : checks condition on column
	auto increment -> based on previous value, increase the value
	Primary key -> unique + not null (can be auto increment)
		One table will have only one primary key 
		Student -> StudentID -> PK
		MarksID -> FK, LecturerID -> FK

		Marks -> MarkID -> PK
		Lecturer -> LecturerID -> PK

	Foreign Key -> one table can have multiple foreign keys, and it should be a primary key to the referenced table
		FK -> to bridge the linkage between two tables


create table lecturer (
	LecturerId int NOT NULL UNIQUE auto_increment,
    StudentId int,
    Age int,
    isExperienced boolean DEFAULT false,
    Check (Age >= 25),
    PRIMARY KEY(LecturerId),
    FOREIGN KEY(StudentId) REFERENCES students(StudentID)
);

Alter table students
ADD Primary Key (StudentId);

Generated one :

ALTER TABLE `university`.`students` 
CHANGE COLUMN `isCertified` `isCertified` TINYINT(1) NULL DEFAULT 0 ,
CHANGE COLUMN `city` `city` VARCHAR(200) CHARACTER SET 'utf8mb3' NULL DEFAULT 'London' ,;

Group By : exists with aggregate functions : count, sum, min, max, avg
		groups the rows that have same values

Having : Where condition in group by statements

select count(StudentId), city  from students where StudentId > 3 group by city order by city desc;

select count(StudentId), city  from students group by city having count(StudentId) = 3 order by count(StudentId) desc

select count(MarksId), FirstName  from marks group by FirstName;

Joins  :  
		
	   to combine two or more tables based on related column between then
	   
	   Inner Join : bring data that have matching values in both tables
	   Right Join : brings data from right table and matching from left
	   Left Join : brings data from left table and matching from right
	   Cross Join (Cartersian Join) : returns all data from both tables
	   Self Join


	   Inner Join :

	   Select stu.*, mar.Marks from students stu
	   Inner join marks mar
       ON stu.StudentId = mar.StudentId;

Left Join :

Select stu.*, mar.Marks from students stu
Left join marks mar
ON stu.StudentId = mar.StudentId;

Select stu.*, mar.Marks from marks mar
Left join students stu
ON stu.StudentId = mar.StudentId;


Right Join :

Select stu.*, mar.Marks from students stu
Right join marks mar
ON stu.StudentId = mar.StudentId;

Select stu.*, mar.Marks from marks mar
Right join students stu
ON stu.StudentId = mar.StudentId;

Cross Join :

Select stu.*, mar.Marks from students stu
Cross join marks mar

using where condition on a cross join :

Select stu.*, mar.Marks from students stu
Cross join marks mar where stu.StudentId = mar.StudentId;

Select stu.*, mar.Marks from students stu
Cross join marks mar 
ON stu.StudentId = mar.StudentId; 

Select stu.*, mar.Marks from marks mar
Right join students stu
ON stu.StudentId = mar.StudentId where StudentId > 3;

Self Join :

select a.FirstName as Student1, B.FirstName as Student2, A.city
from students a , students b
where a.FirstName <> b.FirstName
and a.city  = b.city
order by a.city;

<> -> != operator

Multiple tables and multiple joins

Select stu.*, mar.Marks from (students stu
Inner join marks mar
Left join lecturer lec
ON stu.StudentId = mar.StudentId
on stu.StudentId =  lec.StudentId);

Union and Union all 

Select FirstName as result from students
union all
Select StudentId from marks

Select FirstName, LastName result from students stu
union all
Select FirstName, StudentId from marks

union -> distinct or unique records
union all -> all rec even they are duplicated

JDBC : Java Database Connectivity

Download jar -> https://dev.mysql.com/downloads/connector/j/

Select platform independent. Download the zip and unzip it. 

Register the driver class
Create a connection
Create a statement
Execute the query
Close the connection object
	
JDBC with maven

maven(m2)/gradle -> build tools

install maven in PC : https://maven.apache.org/download.cgi
env variables give path

m2 -> https://mvnrepository.com/
	dependencies , pick the version

maven LifeCycle :

mvn clean install -> lifecycle steps till install

mvn clean install -DskipTests -> skip unit test part

to view jars/xml files -> JavaDecompiler : https://java-decompiler.github.io/

Read about :

indexes 
Stored procedure

ACID principles, transaction management
DB profiling
DB Normalisation
DB Query Optimization techniques

MongoDB : NoSQL(DynamoDB, Cassandra, MariaDB, DocumentDB) : JSON 

no tables and no rows
Documents, Collections

Installation : https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-windows/

Community version : https://www.mongodb.com/try/download/community

Server from above link 

Tools : Install mongoshell and mongoGUI or from robo mongo site download robo mongo : https://robomongo.org/

Tables -> Collections here
Rows & Columns -> Documents & Keys

cmd : check mongosh --version
connect to mongo using : mongosh

27017 -> default port for mongodb

show dbs -> existing database

use dbName -> 
	switches to that DB and uses this db for further query processing
	use dbName which doesn't exit it creates a dbName temporarily

Delete DB : be in that db > db.dropDatabase();

db.createCollection("collectionName") -> It creates a db with collection

drop collection :

	db.collectionName.drop();	

Inserting data :

db.marks.insertOne({"subject" : "Maths", sem : 1, isPassed : true, dateOfEvaluation : Date() })

Many objects : array.. 

db.marks.insertMany([{"subject" : "Physics", sem : 1, isPassed : true, dateOfEvaluation : Date() }, {"subject" : "Chemistry", sem : 1, isPassed : true, dateOfEvaluation : Date() }])

Import JSON -> in compass

Read : db.CollectionName.operation

	db.marks.find() -> reads all docs
	db.marks.findOne() -> first document in collection
	db.marks.find({sem : 1}) -> where condition in {}
	db.marks.find({sem : 1, isPassed : true})

	db.marks.find({}, {sem : 1}) //projection object
	db.marks.find({}, {sem : 1, _id:0}) -> will not bring id
	db.marks.find({}, {sem : 1, _id:1}) -> brings id

Update :

	 db.marks.updateOne({sem : 1}, {$set:{tenure:15}})
	 db.marks.updateMany({sem : 1}, {$set:{tenure:15}})
	 	If tenure key is present in json, it updates otherwise it adds

db.marks.updateMany({sem : 1}, {$set:{tenure:15, dateOfModification : Date()}})

upsert : true -> if document is not present, it shall insert object

db.marks.updateMany({sem : 2}, {$set:{tenure:15}}, {upsert:true})

Update Operators : https://www.mongodb.com/docs/manual/reference/operator/update-field/


Arrays Operators :
https://www.mongodb.com/docs/manual/reference/operator/update/positional/

db.marks.updateMany({},{ $addToSet:  { scores: { $each: [ 90, 92, 85 ] } }})

db.marks.insertOne({myMap : {key1 : "value1", key2 : "value2"}})
db.marks.updateMany({}, {$set : {myMap : {key1 : "value1", key2 : "value2"}}})

Delete :

student> db.marks.deleteOne({}) //delete first record
{ acknowledged: true, deletedCount: 1 }
student> db.marks.deleteOne({name : "John"}) //delete first matched record
{ acknowledged: true, deletedCount: 0 }
student> db.marks.deleteOne({sem : 1}) //delete first matched record
{ acknowledged: true, deletedCount: 1 }
student> db.marks.deleteMany({sem : 1}) //delete all matched records
{ acknowledged: true, deletedCount: 4 }
student> db.marks.deleteMany({}) //delete all records
{ acknowledged: true, deletedCount: 27 }

Read about index in Mongo

db.marks.find({sem :1}).explain("executionStats")
 
  db.marks.createIndex({'sem' : 1}) -> create index on a key, 1 and -1 means ascending order and desc order respectively

  See docsExamined after indexing

 Comparision operators : 
 
 https://www.mongodb.com/docs/manual/reference/operator/query-comparison/

 $eq, $ne, $gt, $gte, $lt, $lte, $nin (not in -> array)

 Aggregate Functions/Operators : https://www.mongodb.com/docs/manual/aggregation/

 sum, count, group, distinct, match etc

 Store and execute queries in mongo : 

student> const/let/var priceOperation = db.marks.find().map(function(e){return e.product_price}).toArray();

student> priceOperation
[]
student> for(const price of priceOperation){print ("Product price is " + price)}

student> const products = db.marks.find();

student> products -> prints all documents in the collection as per query

Validation Mongo : 

https://www.mongodb.com/docs/manual/core/schema-validation/specify-json-schema/#std-label-schema-validation-json


Web Application : facebook.com, github.com

	Single Tier :
			app logic, data processing, UI -> servlets

	Two Tier :
			two layers : front-end layer(client) and back-end layer(server)

Monolithic :

	whole app is built as a single unit.
		Tightly coupled : one is dependant on other

					
Microservices : blocks or small units separately 
		Loosely coupled : services communicate over network
			microservice communication

R.E.S.T & Rest API : Representational State Transfer
	SOAP -> XML based
	Rest -> plain text, HTML, XML, YAML, and JSON
	Graph QL

Principles :

	Stateless : no session state is stored on server btwn requests
	Uniform Interface : to interact with resources
	Client-Server : separate client and server
	Cacheable : Responses can be cached to improve performance
	Layered System : load balancers, proxies, 
	Code on Demand 

HTTP -> sent over network and clients are decoupled from servers

Methods : GET, POST, PUT, PATCH, DELETE	to communicate with resources (rep by URLS)

Rest API :Application Program Interface :  CRUD ops

	resources : /users, /products, /employees
	http methods
	status code : 200 OK, 201 Created, 404 not found

		1xx informational response  the request was received, continuing process
		2xx successful  the request was successfully received, understood, and accepted
		3xx redirection  further action needs to be taken in order to complete the request
		4xx client error  the request contains bad syntax or cannot be fulfilled
		5xx server error  the server failed to fulfil an apparently valid request

Java Containers & Servlets : 

	Java EE -> JSP (Java server pages acts as front-end), Servlet runs inside servlet container (netty, tomcat, jetty)

	Java container -> manage requests and lifecycle of servlet (initialize, request handling, destruction), provides security, txn management etc

Introduction to Software Design Patterns : 	23..

	Reusable solutions to common problems in software design

Types : 

	Creational : Singleton, Factory etc
 
	Structural : Adapter, Composite etc

	Behavioral : Observer, Strategy etc

Use Case : maintainability, efficient problem-solving

****************** SPRING ************************

Spring Beans : Objects managed by spring framework
	xml
	annotations 

Before spring -> Java EE -> Servlets, JSP, and JPA

on CSS -> Bootstrap similarly on Java -> Spring	

Pros : less code, easy to maintain
all configurations you write in a file, read through xml or properties or annotations
reduces boiler plate code (repeatition of code)	

CricketCoach object and FootBallCoach Object are tightly coupled? 

To make it as loose coupling, we create an interface.

Spring context -> container -> manage all our beans and bean lifecycle

	Bean Factory
	Application Context

Spring AOP : Aspect Oriented Programming : logging, txn management, security	

Spring IOC -> Inversion of Control : responsibility of object creation is on spring
		
		Spring takes care of object creation till object destruction

DI -> Dependency Injection -> while creating objects, if there's any dependency	req from other classes ---> it will be injected into your respective beans
	
Constructor Injection //best thing to do
Setter Injection //second priority to use
Field Injection //least priority to use

Scope of Bean : define the lifecycle &  visibility of bean -> spring container

how many instances(copies) of beans are created and how long they're maintained

	1. Singleton(default) -> for stateless beans across app (one bean can be alive)
	2. Prototype -> as per state multiple beans can be used

	-> Request, Session, Application 
	-> WebSocket 
	-> custom scope can also be created

	Singleton -> same hash for multiple objects, destroy method will be called when context is closed 

    prototype -> different hash, different objects,destroy method won't be called

Stereotype Annoatations : Spring will automatically	import the beans into container and inject the dependencies in the app Context
	specific role or purpose of annotation

	1. @Component -> class-level, to mark Spring beans
	2. @Service
	3. @Controller
	4. @Repository

@Configuration
@ComponentScan("com.spring.demo")
@PropertySource("application.properties")	
@Value -> to read properties from app.properties file

@Autowired -> injects dependencies of other class into required class

	Field level ->
		    @Autowired
    		private WishService wishService; //field level injection

    Setter Injection ->
    
    	@Autowired
    	public void setWishService(WishService wishService) {
        	this.wishService = wishService;
    	}

    Constructor Injection ->
    
    	    @Autowired
    	public CricketCoach(WishService wishService) {
       	 this.wishService = wishService;
    	}
	
	@Autowired -> Injecting your dependencies
                : constructor -> mandatory fields
                : setter -> optional fields
                : field/class level

@Qualifier -> to give priority to beans
@PostConstruct -> During bean initialization
@PreDestroy -> Before destruction


@Scope(value = BeanDefinition.SCOPE_SINGLETON)
@Scope("prototype")
@Bean -> to use/call third-party libraries (read access)	
	ModelMapper


Spring MVC : Model View Controller
	
	Build web applications

	Model : rep application data
	View : handling the presentation layer -> html, css, jsp, thymeleaf
	Controller : handle incoming requests & returns processed(validate) response

Dispatcher Servlet : central component which routes all the requests to available and respective controllers
	
	bank : pay, acc, cards

External Server -> should be integrated with the application

Spring Boot : 

Embedded Server -> internally by default it uses tomcat server (you can change the internal server by adding depedency of other server like jetty, netty etc, exclude tomcat server dependency)

Started dependencies to reduce boiler plate code

spring-boot-starters -> dependency management

Manual config in mvc but boot provides auto-configuration

mvc -> web apps, boot -> stand alone apps with min config	

spring boot web(servlet) stack : 

spring web : for building apps with mvc

spring intializr : new spring boot projects 

<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <version>3.4.0</version>
</dependency>


Creating a simple Rest API : use Spring Initializr or manual config

manual config -> we checked

https://start.spring.io/ -> from here

@SpringBootApplication -> at main level

controller, service, repository -> alias of Component

@RestController -> @Controller + @Response Body

@GetMapping -> for get API
	    @RequestMapping(value = "/welcome/{name}", method = RequestMethod.GET)

@RequestMapping
@PathVariable

URL : http://localhost:8080/api/welcome/{name}

    welcome/{name} --> end-point
    localhost -> domain/host
    8080 -> port
    localhost:8080 -> base uri/url
    http/https -> protocol

    change port : in app.prop -> server.port=8181

Additional dependencies :

Spring Boot Dev Tools -> live reload the changes in application

lombok : provides annotations for reducing boiler plate code

	https://projectlombok.org/download

	@Data -> Equivalent to @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode.
	@NoArgsConstructor	-> default constructor
    @AllArgsConstructor -> with all params

To use other server :

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
	<exclusions>
		<!-- Exclude the Tomcat dependency -->
		<exclusion>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
		</exclusion>
	</exclusions>
</dependency>
<!-- Use Jetty instead -->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jetty</artifactId>
</dependency>    

Spring Data JPA : Java persistence API

	JDBC -> to interact with DB from Java, offers more control

	hibernate -> again JPA built on hibernate 
					-> reduces boiler plate code
					-> spring data JPA
					-> Java specification, not an implementation

New Project -> (maven)
	pom.xml -> lombok, mysql-connector-j, hibernate-core

hibernate.cfg.xml -> Doctype, tags, connections

Create an entity ->

@Entity
@Table(name = "students")
@Id
Autogenerated-> @GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "FirstName")

one person can place many orders : OneToMany Mapping

   personId : 
   	PK in Persons table
   	FK in Orders table 

Persons.java ->

    @OneToMany(mappedBy = "persons")
    private List<Orders> orders;

Orders.java
    @ManyToOne
    @JoinColumn(name = "personId")
    private Persons persons;    

*** Spring Data JPA ***

spring initializr : 

Spring Web 
Lombok 
Developer Tools
MySQL driver.
Spring Data JPA 

Postman Download : https://www.postman.com/

@Service
@Repository
@PostMapping
@RequestBody

packages -> entity, controller, service (interface and class), repository